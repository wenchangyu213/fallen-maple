[1,["c7tLm9ayBKsa3d4yY9cyZJ@0089c","c7tLm9ayBKsa3d4yY9cyZJ@9b633","c7tLm9ayBKsa3d4yY9cyZJ@3effa","c7tLm9ayBKsa3d4yY9cyZJ@221a5","9e5LMmDM1Nr5quRtQU+fOS"],["mainTexture","occlusionMap","emissiveMap","pbrMap","normalMap","_effectAsset"],[["cc.Material",["_name","_states","_defines","_props"],0,12],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,3,4],[1,0,1,2,4]],[[[[0,"CAR_LOW1_Baked",[{"rasterizerState":{"cullMode":0},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_NORMAL_MAP":true,"USE_PBR_MAP":true,"USE_OCCLUSION_MAP":true,"USE_EMISSIVE_MAP":true}],[[[{"metallic":1,"emissive":10},"mainColor",8,[4,4283314688],"emissiveColor",8,[4,4294967295],"mainTexture",6,0,"occlusionMap",6,1,"emissiveMap",6,2,"pbrMap",6,3,"normalMap",6,4]],11]]],0,0,[0,0,0,0,0,0],[0,1,2,3,4,5],[1,0,2,0,3,4]],[[[1,"../materials/standard",[{"hash":3458347247,"name":"../materials/standard|standard-vs:vert|standard-fs:frag","blocks":[{"name":"StandardConstants","stageFlags":17,"binding":0,"members":[{"name":"mainColor","type":16,"count":1},{"name":"emissiveColor","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"inputParams","type":16,"count":1},{"name":"inputParams2","type":16,"count":1},{"name":"mainTexture_ST","type":16,"count":1},{"name":"normalMap_ST","type":16,"count":1},{"name":"pbrMap_ST","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"noiseMap","type":28,"count":1,"stageFlags":1,"binding":1,"defines":["USE_PARTICLE"]},{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"occlusionMap2","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_OCCLUSION_MAP2"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"lightmap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_LIGHTMAP"]},{"name":"indirectmap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_INDIRECTMAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]},{"name":"a_texCoord1","format":21,"location":17,"defines":[]},{"name":"a_centroid","format":32,"location":18,"defines":["USE_PARTICLE"]},{"name":"a_controlPoint0","format":32,"location":19,"defines":["USE_PARTICLE"]},{"name":"a_controlPoint1","format":32,"location":20,"defines":["USE_PARTICLE"]},{"name":"a_endPosition","format":32,"location":21,"defines":["USE_PARTICLE"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"StandardConstants","stageFlags":17,"binding":0,"members":[{"name":"mainColor","type":16,"count":1},{"name":"emissiveColor","type":16,"count":1},{"name":"albedoScaleAndCutoff","type":16,"count":1},{"name":"inputParams","type":16,"count":1},{"name":"inputParams2","type":16,"count":1},{"name":"mainTexture_ST","type":16,"count":1},{"name":"normalMap_ST","type":16,"count":1},{"name":"pbrMap_ST","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"noiseMap","type":28,"count":1,"stageFlags":1,"binding":1,"defines":["USE_PARTICLE"]},{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":2,"defines":[]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_NORMAL_MAP"]},{"name":"pbrMap","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_PBR_MAP"]},{"name":"occlusionMap","type":28,"count":1,"stageFlags":16,"binding":5,"defines":["USE_OCCLUSION_MAP"]},{"name":"occlusionMap2","type":28,"count":1,"stageFlags":16,"binding":6,"defines":["USE_OCCLUSION_MAP2"]},{"name":"emissiveMap","type":28,"count":1,"stageFlags":16,"binding":7,"defines":["USE_EMISSIVE_MAP"]},{"name":"lightmap","type":28,"count":1,"stageFlags":16,"binding":8,"defines":["USE_LIGHTMAP"]},{"name":"indirectmap","type":28,"count":1,"stageFlags":16,"binding":9,"defines":["USE_INDIRECTMAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"tags":{"builtin":"global"},"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    in vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n    highp vec4 cc_reflectionProbeBlendData1;\n    highp vec4 cc_reflectionProbeBlendData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\nlayout(std140) uniform StandardConstants {\n  vec4 mainColor;\n  vec4 emissiveColor;\n  vec4 albedoScaleAndCutoff;\n  vec4 inputParams;\n  vec4 inputParams2;\n  vec4 mainTexture_ST;\n  vec4 normalMap_ST;\n  vec4 pbrMap_ST;\n};\n  in vec2 a_texCoord1;\n  out vec2 v_uv;\n  out vec2 v_uv1;\n  out vec3 v_view;\n  out vec3 v_worldPos;\n  out vec3 v_normal;\n  out vec4 v_screenPos;\n  out vec3 v_emissive;\n#if USE_NORMAL_MAP\n  out vec2 v_uvN;\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if USE_PBR_MAP\n  out vec2 v_uvPBR;\n#endif\n#if USE_PARTICLE\n  in vec3 a_centroid;\n  in vec3 a_controlPoint0;\n  in vec3 a_controlPoint1;\n  in vec3 a_endPosition;\n  out float v_progress;\n  uniform sampler2D  noiseMap;\n  #define u_progress inputParams2.w\nvec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return\n    tn * tn * tn * p0 +\n    3.0 * tn * tn * t * c0 +\n    3.0 * tn * t * t * c1 +\n    t * t * t * p1;\n}\n#endif\nfloat pow2( const in float x ) { return x*x; }\nvec4 getStandardInput() {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  v_uv = a_texCoord * mainTexture_ST.xy + mainTexture_ST.zw;\n  v_uv1 = a_texCoord1;\n  vec4 position = In.position;\n#if USE_PARTICLE\n#if USE_PARTICLE2\n  float startTime = texture(noiseMap, v_uv * 1.26).r;\n  vec3  startPosition = mix(vec3(0.,0.,-.1), vec3(0.,0.,0.07), smoothstep(1., 1.5, u_progress));\n  float progress = mix(-0.7*pow2(u_progress-2.1)+3., -1.5*pow2(u_progress-1.)+1.5, step(.16, a_centroid.z));\n  progress = saturate(progress - startTime);\n  position.xyz = mix(startPosition, position.xyz, progress);\n#else\n  float startTime = texture(noiseMap, v_uv * 1.3).r;\n  vec3  startPosition = vec3(0.);\n  float progress = saturate(u_progress - startTime);\n#endif\n  position.xyz = (position.xyz - a_centroid) * mix(1., 0., progress) + a_centroid;\n  position.xyz += cubicBezier(startPosition, a_controlPoint0, a_controlPoint1, a_endPosition, progress);\n  v_progress = progress;\n#endif\n  vec4 worldPos = matWorld * position;\n  v_worldPos = worldPos.xyz;\n  v_view = cc_cameraPos.xyz - worldPos.xyz;\n#if USE_NORMAL_MAP\n  v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  v_uvN = a_texCoord * normalMap_ST.xy + normalMap_ST.zw;\n#endif\n#if USE_PBR_MAP\n  v_uvPBR = a_texCoord * pbrMap_ST.xy + pbrMap_ST.zw;\n#endif\n  vec4 ndc = cc_matViewProj * worldPos;\n  v_screenPos = (ndc + ndc.w) * 0.5;\n  return ndc;\n}\nvec4 vert() {\n  return getStandardInput();\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nlayout(std140) uniform StandardConstants {\n  vec4 mainColor;\n  vec4 emissiveColor;\n  vec4 albedoScaleAndCutoff;\n  vec4 inputParams;\n  vec4 inputParams2;\n  vec4 mainTexture_ST;\n  vec4 normalMap_ST;\n  vec4 pbrMap_ST;\n};\nvec3 sRGB2Linear(in vec3 x) {\n  return x * x;\n}\nvec3 linearColorSpace(in vec3 x) {\n#if USE_LINEAR_COLOR\n  return x;\n#else\n  return sRGB2Linear(x);\n#endif\n}\n#define RGBM_STD 0\n#define RGBM_MAXRANGE 8.0\n#define RGBM_MAXRANGE_SQRT 4.0\nvec3 RGBM2Linear(vec4 rgbm) {\n  vec3 v = (rgbm.rgb * ((1. - rgbm.a) * RGBM_MAXRANGE_SQRT));\n  return v * v;\n}\nstruct MaterialInfo {\n  vec4  pixel;\n  vec3  albedo;\n  float alpha;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3  normal;\n  vec3  viewDir;\n  vec3  worldPos;\n  vec3  c_diffuse;\n  vec3  f0;\n  vec3  f90;\n  float specularWeight;\n  vec3  k_S;\n  vec3  k_D;\n  vec3  emissive;\n};\n  in vec2 v_uv;\n  in vec2 v_uv1;\n  in vec3 v_view;\n  in vec3 v_worldPos;\n  in vec3 v_normal;\n  in vec4 v_screenPos;\n  uniform sampler2D mainTexture;\n#if USE_PBR_MAP\n  in vec2 v_uvPBR;\n#endif\n#if USE_NORMAL_MAP\n  in vec2 v_uvN;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_OCCLUSION_MAP2\n  uniform sampler2D occlusionMap2;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_PARTICLE\n  in float v_progress;\n#endif\n#define u_roughness   inputParams.x\n#define u_metallic    inputParams.y\n#define u_occlusion   inputParams.z\n#define u_normalScale inputParams.w\n#define u_emissive    albedoScaleAndCutoff.w\n#define u_indirectIntensity inputParams2.x\n#define DIELECTRIC_SPECULAR 0.04\nMaterialInfo getMaterialInfo() {\n  MaterialInfo materialInfo;\n  materialInfo.roughness = u_roughness;\n  materialInfo.metallic = u_metallic;\n  materialInfo.ao = 1.0;\n  materialInfo.emissive = emissiveColor.rgb * u_emissive;\n#if USE_SCREEN_POS\n  vec4 pixel = texture(mainTexture, v_screenPos.xy / v_screenPos.w);\n#else\n  vec4 pixel = texture(mainTexture, v_uv);\n#endif\n  materialInfo.albedo = mainColor.rgb * albedoScaleAndCutoff.xyz * linearColorSpace(pixel.rgb);\n  materialInfo.alpha  = mainColor.a * pixel.a;\n  materialInfo.pixel = pixel;\n  materialInfo.viewDir = normalize(v_view);\n  materialInfo.worldPos = v_worldPos;\n  vec3 ng = normalize(v_normal);\n#if USE_NORMAL_MAP\n  vec3 t = normalize(v_tangent);\n  vec3 b = normalize(v_bitangent);\n  vec3 n = texture(normalMap, v_uvN).rgb * 2.0 - 1.0;\n  n *= vec3(u_normalScale, u_normalScale, 1.0);\n  materialInfo.normal = normalize(mat3(t, b, ng) * normalize(n));\n#else\n  materialInfo.normal = ng;\n#endif\n#if USE_PBR_MAP\n  vec4  MR = texture(pbrMap, v_uvPBR);\n  materialInfo.roughness *= MR.g;\n  materialInfo.metallic *= MR.b;\n#endif\nvec3 dxy = max(abs(dFdx(ng)), abs(dFdy(ng)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterialInfo.roughness += geometryRoughness;\nmaterialInfo.roughness = min(materialInfo.roughness, 1.0);\n#if USE_OCCLUSION_MAP\n  float ao = texture(occlusionMap, OCCLUSION_UV).r;\n#if USE_OCCLUSION_MAP2\n  float ao2 = texture(occlusionMap2, OCCLUSION_UV).r;\n  ao = mix(ao2, ao, u_indirectIntensity);\n#endif\n  materialInfo.ao = mix(1., ao, u_occlusion);\n#endif\n#if USE_EMISSIVE_MAP\n  materialInfo.emissive *= linearColorSpace(texture(emissiveMap, v_uv).rgb);\n#endif\n#if USE_PARTICLE\n  float p = step(0.01, v_progress);\n  materialInfo.ao = mix(materialInfo.ao, 1., p);\n#endif\n  materialInfo.c_diffuse = (1.0 - DIELECTRIC_SPECULAR) * (1.0 - materialInfo.metallic) * materialInfo.albedo;\n  materialInfo.f0 = mix(vec3(DIELECTRIC_SPECULAR), materialInfo.albedo, materialInfo.metallic);\n  materialInfo.f90 = vec3(1.0);\n  materialInfo.specularWeight = 1.0;\n  materialInfo.k_S = vec3(1.0);\n  materialInfo.k_D = vec3(1.0);\n  return materialInfo;\n}\n#define PI               3.14159265359\n#define PI2              6.28318530718\n#define PI1_2            1.5707963267949\n#define RECIPROCAL_PI    0.31830988618\n#define RECIPROCAL_PI2   0.15915494\n#define RECIPROCAL_PI1_2 0.636619772367\n#define LOG2E            1.442695\n#define LOG4E            0.721347\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define INFINITY         1000000.0\n#define saturate(a) clamp(a, 0.0, 1.0)\n#define saturateDot(a, b) saturate(dot(a, b))\n#define whiteCompliment(a)(1.0 - saturate(a))\n#define MEDIUMP_FLT_MAX    65504.0\n#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)\nvec3 F_SchlickRoughness(vec3 F0, float roughness, float dotNV) {\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  return F0 + Fr * exp2((-5.55473 * dotNV - 6.98316) * dotNV);\n}\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n  highp vec4 cc_localShadowBias;\n  highp vec4 cc_reflectionProbeData1;\n  highp vec4 cc_reflectionProbeData2;\n  highp vec4 cc_reflectionProbeBlendData1;\n  highp vec4 cc_reflectionProbeBlendData2;\n};\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n#endif\nvec2 EnvBRDFApproxLazarov(float Roughness, float NoV) {\n  const mediump vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const mediump vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = Roughness * c0 + c1;\n  mediump float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  mediump vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return AB;\n}\nstruct RadianceCoeff {\n  vec3 k_S;\n  vec3 k_D;\n};\nRadianceCoeff getRadianceCoeff(MaterialInfo materialInfo, float NoV) {\n  vec2 f_ab = EnvBRDFApproxLazarov(materialInfo.roughness, NoV);\n  vec3 F0 = materialInfo.f0;\n  vec3 k_S = F_SchlickRoughness(F0, materialInfo.roughness, NoV);\n  vec3 FssEss = materialInfo.specularWeight * k_S * f_ab.x + f_ab.y;\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = materialInfo.specularWeight * (F0 + (1.0 - F0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = materialInfo.c_diffuse * (1.0 - FssEss + FmsEms);\n  RadianceCoeff coeff;\n  coeff.k_S = FssEss;\n  coeff.k_D = FmsEms + k_D;\n  return coeff;\n}\nvec3 boxProjection(vec3 dir, vec3 worldPos, vec3 probePos, vec3 boxMin, vec3 boxMax) {\n    vec3 tbot = boxMin - worldPos;\n    vec3 ttop = boxMax - worldPos;\n    vec3 tmax = mix(tbot, ttop, step(vec3(0), dir));\n    tmax /= dir;\n    float t = min(min(tmax.x, tmax.y), tmax.z);\n    return worldPos + dir * t - probePos;\n}\n#define MAX_MIP_LEVEL cc_ambientGround.w\nvec3 getIBLDiffuseRadiance(vec3 n, vec3 worldPos) {\n#if CC_USE_REFLECTION_PROBE\n  vec4 env = fragTextureLod(cc_reflectionProbeCubemap, n, MAX_MIP_LEVEL - 1.0);\n#else\n  vec4 env = fragTextureLod(cc_environment, n, MAX_MIP_LEVEL - 1.0);\n#endif\n#if CC_USE_IBL == 2\n  return unpackRGBE(env);\n#else\n  return env.rgb;\n#endif\n}\nvec3 getIBLSpecularRadiance(vec3 dir, float roughness, vec3 worldPos) {\n  float mip = roughness * (MAX_MIP_LEVEL - 1.0);\n#if CC_USE_REFLECTION_PROBE\n  vec3 centerPos = cc_reflectionProbeData1.xyz;\n  vec3 boxHalfSize = cc_reflectionProbeData2.xyz;\n  dir = boxProjection(dir, worldPos, centerPos, centerPos - boxHalfSize, centerPos + boxHalfSize);\n  vec4 env = fragTextureLod(cc_reflectionProbeCubemap, dir, mip);\n#else\n  vec4 env = fragTextureLod(cc_environment, dir, mip);\n#endif\n#if CC_USE_IBL == 2\n  return unpackRGBE(env);\n#else\n  return env.rgb;\n#endif\n}\nvec3 applyFog(in vec3 col, in vec3 rd, in vec3 p) {\n    float d = 0.15;\n    float t = max(0.,length(rd) - 5.);\n    float f2 = clamp(dot(normalize(rd), vec3(0.,1.,0.)),0.,1.);\n    vec3  fog1 = mix(col, cc_fogColor.rgb, 1.-exp(-t * d));\n    return mix(fog1, cc_fogColor.rgb * mix(1.,1.5,smoothstep(0.,0.5,f2)), 1.-smoothstep(-10.,-5.,p.y));\n}\nfloat pow2( const in float x ) { return x*x; }\nvec3 sweepLight(in float threshold, in float intensity, in float NoV) {\n    float f = pow2(1.0 - NoV);\n    float t = pow2(threshold)*1.2;\n    float p = smoothstep(t-0.2,t-0.1,f)*smoothstep(t,t-0.1,f);\n    return p*vec3(2.,10.,20.)*intensity*0.3;\n}\n#if USE_LIGHTMAP\n  uniform sampler2D lightmap;\n#endif\n#if USE_INDIRECTMAP\n  uniform sampler2D indirectmap;\n#endif\nstruct ShadingResult {\n  float ao;\n  float alpha;\n  vec3  f_diffuse;\n  vec3  f_specular;\n  vec3  f_emissive;\n  vec3  f_diffuseIndirect;\n  vec3  f_specularIndirect;\n};\nShadingResult getStandardShading(MaterialInfo materialInfo) {\n  vec3 n = materialInfo.normal;\n  vec3 v = materialInfo.viewDir;\n  vec3 l = normalize(-cc_mainLitDir.xyz);\n  vec3 h = normalize(l + v);\n  float NoL = saturate(dot(n, l));\n  float NoV = saturate(dot(n, v));\n  float NoH = saturate(dot(n, h));\n  float VoH = saturate(dot(v, h));\n  ShadingResult result;\n  vec3 r = normalize(reflect(-v, n));\n  RadianceCoeff coeff = getRadianceCoeff(materialInfo, NoV);\n#if USE_LIGHTMAP\n  vec4 lm = texture(lightmap, LIGHTMAP_UV);\n  result.f_diffuseIndirect += RGBM2Linear(lm) * materialInfo.c_diffuse * mix(0.5, 1.0, smoothstep(-0.5, 0.0, n.y));\n  result.f_specularIndirect += coeff.k_S * getIBLSpecularRadiance(r, materialInfo.roughness, materialInfo.worldPos);\n#else\n  result.f_diffuseIndirect  += coeff.k_D * getIBLDiffuseRadiance(n, materialInfo.worldPos);\n  result.f_specularIndirect += coeff.k_S * getIBLSpecularRadiance(r, materialInfo.roughness, materialInfo.worldPos);\n#endif\n#if USE_INDIRECTMAP\n  vec4 im = texture(indirectmap, INDIRECTMAP_UV);\n  result.f_diffuseIndirect += (im.rgb) * materialInfo.c_diffuse * u_indirectIntensity;\n#endif\n  result.f_emissive += materialInfo.emissive;\n#if USE_SWEEP_LIGHT\n  result.f_emissive += sweepLight(inputParams2.y, inputParams2.z, NoV);\n#endif\n#if USE_PARTICLE\n#if USE_PARTICLE2\n  result.f_specularIndirect = mix(result.f_specularIndirect, result.f_specularIndirect * vec3(4.,8.,8.), smoothstep(0.,0.1,v_progress));\n#else\n  result.f_specularIndirect = mix(result.f_specularIndirect, result.f_specularIndirect * 8., smoothstep(0.,0.1,v_progress));\n#endif\n#endif\n  return result;\n}\nvec4 getStandardOutput(MaterialInfo materialInfo) {\n  ShadingResult result = getStandardShading(materialInfo);\n  vec3 finalColor = result.f_emissive + result.f_diffuse + result.f_specular + (result.f_diffuseIndirect + result.f_specularIndirect) * materialInfo.ao;\n  finalColor = applyFog(finalColor, v_view, v_worldPos) * cc_debug_view_mode.x;\n  return vec4(finalColor, result.alpha);\n}\nvec4 frag() {\n  MaterialInfo materialInfo = getMaterialInfo();\n  return getStandardOutput(materialInfo);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n  uniform highp vec4 cc_cameraPos;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nfloat saturate(float value) { return clamp(value, 0.0, 1.0); }\nvec2 saturate(vec2 value) { return clamp(value, vec2(0.0), vec2(1.0)); }\nvec3 saturate(vec3 value) { return clamp(value, vec3(0.0), vec3(1.0)); }\nvec4 saturate(vec4 value) { return clamp(value, vec4(0.0), vec4(1.0)); }\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n   uniform vec4 inputParams2;\n   uniform vec4 mainTexture_ST;\n   uniform vec4 normalMap_ST;\n   uniform vec4 pbrMap_ST;\n  attribute vec2 a_texCoord1;\n  varying vec2 v_uv;\n  varying vec2 v_uv1;\n  varying vec3 v_view;\n  varying vec3 v_worldPos;\n  varying vec3 v_normal;\n  varying vec4 v_screenPos;\n  varying vec3 v_emissive;\n#if USE_NORMAL_MAP\n  varying vec2 v_uvN;\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if USE_PBR_MAP\n  varying vec2 v_uvPBR;\n#endif\n#if USE_PARTICLE\n  attribute vec3 a_centroid;\n  attribute vec3 a_controlPoint0;\n  attribute vec3 a_controlPoint1;\n  attribute vec3 a_endPosition;\n  varying float v_progress;\n  uniform sampler2D  noiseMap;\n  #define u_progress inputParams2.w\nvec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return\n    tn * tn * tn * p0 +\n    3.0 * tn * tn * t * c0 +\n    3.0 * tn * t * t * c1 +\n    t * t * t * p1;\n}\n#endif\nfloat pow2( const in float x ) { return x*x; }\nvec4 getStandardInput() {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  v_uv = a_texCoord * mainTexture_ST.xy + mainTexture_ST.zw;\n  v_uv1 = a_texCoord1;\n  vec4 position = In.position;\n#if USE_PARTICLE\n#if USE_PARTICLE2\n  float startTime = texture2D(noiseMap, v_uv * 1.26).r;\n  vec3  startPosition = mix(vec3(0.,0.,-.1), vec3(0.,0.,0.07), smoothstep(1., 1.5, u_progress));\n  float progress = mix(-0.7*pow2(u_progress-2.1)+3., -1.5*pow2(u_progress-1.)+1.5, step(.16, a_centroid.z));\n  progress = saturate(progress - startTime);\n  position.xyz = mix(startPosition, position.xyz, progress);\n#else\n  float startTime = texture2D(noiseMap, v_uv * 1.3).r;\n  vec3  startPosition = vec3(0.);\n  float progress = saturate(u_progress - startTime);\n#endif\n  position.xyz = (position.xyz - a_centroid) * mix(1., 0., progress) + a_centroid;\n  position.xyz += cubicBezier(startPosition, a_controlPoint0, a_controlPoint1, a_endPosition, progress);\n  v_progress = progress;\n#endif\n  vec4 worldPos = matWorld * position;\n  v_worldPos = worldPos.xyz;\n  v_view = cc_cameraPos.xyz - worldPos.xyz;\n#if USE_NORMAL_MAP\n  v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n  v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  v_uvN = a_texCoord * normalMap_ST.xy + normalMap_ST.zw;\n#endif\n#if USE_PBR_MAP\n  v_uvPBR = a_texCoord * pbrMap_ST.xy + pbrMap_ST.zw;\n#endif\n  vec4 ndc = cc_matViewProj * worldPos;\n  v_screenPos = (ndc + ndc.w) * 0.5;\n  return ndc;\n}\nvec4 vert() {\n  return getStandardInput();\n}\nvoid main() { gl_Position = vert(); }","frag":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nuniform mediump vec4 cc_debug_view_mode;\nuniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_ambientGround;\n  uniform mediump vec4 cc_fogColor;\n    uniform vec4 mainColor;\n    uniform vec4 emissiveColor;\n    uniform vec4 albedoScaleAndCutoff;\n    uniform vec4 inputParams;\n    uniform vec4 inputParams2;\nvec3 sRGB2Linear(in vec3 x) {\n  return x * x;\n}\nvec3 linearColorSpace(in vec3 x) {\n#if USE_LINEAR_COLOR\n  return x;\n#else\n  return sRGB2Linear(x);\n#endif\n}\n#define RGBM_STD 0\n#define RGBM_MAXRANGE 8.0\n#define RGBM_MAXRANGE_SQRT 4.0\nvec3 RGBM2Linear(vec4 rgbm) {\n  vec3 v = (rgbm.rgb * ((1. - rgbm.a) * RGBM_MAXRANGE_SQRT));\n  return v * v;\n}\nstruct MaterialInfo {\n  vec4  pixel;\n  vec3  albedo;\n  float alpha;\n  float roughness;\n  float metallic;\n  float ao;\n  vec3  normal;\n  vec3  viewDir;\n  vec3  worldPos;\n  vec3  c_diffuse;\n  vec3  f0;\n  vec3  f90;\n  float specularWeight;\n  vec3  k_S;\n  vec3  k_D;\n  vec3  emissive;\n};\n  varying vec2 v_uv;\n  varying vec2 v_uv1;\n  varying vec3 v_view;\n  varying vec3 v_worldPos;\n  varying vec3 v_normal;\n  varying vec4 v_screenPos;\n  uniform sampler2D mainTexture;\n#if USE_PBR_MAP\n  varying vec2 v_uvPBR;\n#endif\n#if USE_NORMAL_MAP\n  varying vec2 v_uvN;\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_OCCLUSION_MAP2\n  uniform sampler2D occlusionMap2;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_PARTICLE\n  varying float v_progress;\n#endif\n#define u_roughness   inputParams.x\n#define u_metallic    inputParams.y\n#define u_occlusion   inputParams.z\n#define u_normalScale inputParams.w\n#define u_emissive    albedoScaleAndCutoff.w\n#define u_indirectIntensity inputParams2.x\n#define DIELECTRIC_SPECULAR 0.04\nMaterialInfo getMaterialInfo() {\n  MaterialInfo materialInfo;\n  materialInfo.roughness = u_roughness;\n  materialInfo.metallic = u_metallic;\n  materialInfo.ao = 1.0;\n  materialInfo.emissive = emissiveColor.rgb * u_emissive;\n#if USE_SCREEN_POS\n  vec4 pixel = texture2D(mainTexture, v_screenPos.xy / v_screenPos.w);\n#else\n  vec4 pixel = texture2D(mainTexture, v_uv);\n#endif\n  materialInfo.albedo = mainColor.rgb * albedoScaleAndCutoff.xyz * linearColorSpace(pixel.rgb);\n  materialInfo.alpha  = mainColor.a * pixel.a;\n  materialInfo.pixel = pixel;\n  materialInfo.viewDir = normalize(v_view);\n  materialInfo.worldPos = v_worldPos;\n  vec3 ng = normalize(v_normal);\n#if USE_NORMAL_MAP\n  vec3 t = normalize(v_tangent);\n  vec3 b = normalize(v_bitangent);\n  vec3 n = texture2D(normalMap, v_uvN).rgb * 2.0 - 1.0;\n  n *= vec3(u_normalScale, u_normalScale, 1.0);\n  materialInfo.normal = normalize(mat3(t, b, ng) * normalize(n));\n#else\n  materialInfo.normal = ng;\n#endif\n#if USE_PBR_MAP\n  vec4  MR = texture2D(pbrMap, v_uvPBR);\n  materialInfo.roughness *= MR.g;\n  materialInfo.metallic *= MR.b;\n#endif\nvec3 dxy = max(abs(dFdx(ng)), abs(dFdy(ng)));\nfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\nmaterialInfo.roughness += geometryRoughness;\nmaterialInfo.roughness = min(materialInfo.roughness, 1.0);\n#if USE_OCCLUSION_MAP\n  float ao = texture2D(occlusionMap, OCCLUSION_UV).r;\n#if USE_OCCLUSION_MAP2\n  float ao2 = texture2D(occlusionMap2, OCCLUSION_UV).r;\n  ao = mix(ao2, ao, u_indirectIntensity);\n#endif\n  materialInfo.ao = mix(1., ao, u_occlusion);\n#endif\n#if USE_EMISSIVE_MAP\n  materialInfo.emissive *= linearColorSpace(texture2D(emissiveMap, v_uv).rgb);\n#endif\n#if USE_PARTICLE\n  float p = step(0.01, v_progress);\n  materialInfo.ao = mix(materialInfo.ao, 1., p);\n#endif\n  materialInfo.c_diffuse = (1.0 - DIELECTRIC_SPECULAR) * (1.0 - materialInfo.metallic) * materialInfo.albedo;\n  materialInfo.f0 = mix(vec3(DIELECTRIC_SPECULAR), materialInfo.albedo, materialInfo.metallic);\n  materialInfo.f90 = vec3(1.0);\n  materialInfo.specularWeight = 1.0;\n  materialInfo.k_S = vec3(1.0);\n  materialInfo.k_D = vec3(1.0);\n  return materialInfo;\n}\n#define PI               3.14159265359\n#define PI2              6.28318530718\n#define PI1_2            1.5707963267949\n#define RECIPROCAL_PI    0.31830988618\n#define RECIPROCAL_PI2   0.15915494\n#define RECIPROCAL_PI1_2 0.636619772367\n#define LOG2E            1.442695\n#define LOG4E            0.721347\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define INFINITY         1000000.0\n#define saturate(a) clamp(a, 0.0, 1.0)\n#define saturateDot(a, b) saturate(dot(a, b))\n#define whiteCompliment(a)(1.0 - saturate(a))\n#define MEDIUMP_FLT_MAX    65504.0\n#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)\nvec3 F_SchlickRoughness(vec3 F0, float roughness, float dotNV) {\n  vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n  return F0 + Fr * exp2((-5.55473 * dotNV - 6.98316) * dotNV);\n}\nuniform highp vec4 cc_reflectionProbeData1;\n  uniform highp vec4 cc_reflectionProbeData2;\nuniform samplerCube cc_environment;\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(1.1, rgbe.a * 255.0 - 128.0);\n}\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n#endif\nvec2 EnvBRDFApproxLazarov(float Roughness, float NoV) {\n  const mediump vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const mediump vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = Roughness * c0 + c1;\n  mediump float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n  mediump vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return AB;\n}\nstruct RadianceCoeff {\n  vec3 k_S;\n  vec3 k_D;\n};\nRadianceCoeff getRadianceCoeff(MaterialInfo materialInfo, float NoV) {\n  vec2 f_ab = EnvBRDFApproxLazarov(materialInfo.roughness, NoV);\n  vec3 F0 = materialInfo.f0;\n  vec3 k_S = F_SchlickRoughness(F0, materialInfo.roughness, NoV);\n  vec3 FssEss = materialInfo.specularWeight * k_S * f_ab.x + f_ab.y;\n  float Ems = (1.0 - (f_ab.x + f_ab.y));\n  vec3 F_avg = materialInfo.specularWeight * (F0 + (1.0 - F0) / 21.0);\n  vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n  vec3 k_D = materialInfo.c_diffuse * (1.0 - FssEss + FmsEms);\n  RadianceCoeff coeff;\n  coeff.k_S = FssEss;\n  coeff.k_D = FmsEms + k_D;\n  return coeff;\n}\nvec3 boxProjection(vec3 dir, vec3 worldPos, vec3 probePos, vec3 boxMin, vec3 boxMax) {\n    vec3 tbot = boxMin - worldPos;\n    vec3 ttop = boxMax - worldPos;\n    vec3 tmax = mix(tbot, ttop, step(vec3(0), dir));\n    tmax /= dir;\n    float t = min(min(tmax.x, tmax.y), tmax.z);\n    return worldPos + dir * t - probePos;\n}\n#define MAX_MIP_LEVEL cc_ambientGround.w\nvec3 getIBLDiffuseRadiance(vec3 n, vec3 worldPos) {\n#if CC_USE_REFLECTION_PROBE\n  vec4 env = fragTextureLod(cc_reflectionProbeCubemap, n, MAX_MIP_LEVEL - 1.0);\n#else\n  vec4 env = fragTextureLod(cc_environment, n, MAX_MIP_LEVEL - 1.0);\n#endif\n#if CC_USE_IBL == 2\n  return unpackRGBE(env);\n#else\n  return env.rgb;\n#endif\n}\nvec3 getIBLSpecularRadiance(vec3 dir, float roughness, vec3 worldPos) {\n  float mip = roughness * (MAX_MIP_LEVEL - 1.0);\n#if CC_USE_REFLECTION_PROBE\n  vec3 centerPos = cc_reflectionProbeData1.xyz;\n  vec3 boxHalfSize = cc_reflectionProbeData2.xyz;\n  dir = boxProjection(dir, worldPos, centerPos, centerPos - boxHalfSize, centerPos + boxHalfSize);\n  vec4 env = fragTextureLod(cc_reflectionProbeCubemap, dir, mip);\n#else\n  vec4 env = fragTextureLod(cc_environment, dir, mip);\n#endif\n#if CC_USE_IBL == 2\n  return unpackRGBE(env);\n#else\n  return env.rgb;\n#endif\n}\nvec3 applyFog(in vec3 col, in vec3 rd, in vec3 p) {\n    float d = 0.15;\n    float t = max(0.,length(rd) - 5.);\n    float f2 = clamp(dot(normalize(rd), vec3(0.,1.,0.)),0.,1.);\n    vec3  fog1 = mix(col, cc_fogColor.rgb, 1.-exp(-t * d));\n    return mix(fog1, cc_fogColor.rgb * mix(1.,1.5,smoothstep(0.,0.5,f2)), 1.-smoothstep(-10.,-5.,p.y));\n}\nfloat pow2( const in float x ) { return x*x; }\nvec3 sweepLight(in float threshold, in float intensity, in float NoV) {\n    float f = pow2(1.0 - NoV);\n    float t = pow2(threshold)*1.2;\n    float p = smoothstep(t-0.2,t-0.1,f)*smoothstep(t,t-0.1,f);\n    return p*vec3(2.,10.,20.)*intensity*0.3;\n}\n#if USE_LIGHTMAP\n  uniform sampler2D lightmap;\n#endif\n#if USE_INDIRECTMAP\n  uniform sampler2D indirectmap;\n#endif\nstruct ShadingResult {\n  float ao;\n  float alpha;\n  vec3  f_diffuse;\n  vec3  f_specular;\n  vec3  f_emissive;\n  vec3  f_diffuseIndirect;\n  vec3  f_specularIndirect;\n};\nShadingResult getStandardShading(MaterialInfo materialInfo) {\n  vec3 n = materialInfo.normal;\n  vec3 v = materialInfo.viewDir;\n  vec3 l = normalize(-cc_mainLitDir.xyz);\n  vec3 h = normalize(l + v);\n  float NoL = saturate(dot(n, l));\n  float NoV = saturate(dot(n, v));\n  float NoH = saturate(dot(n, h));\n  float VoH = saturate(dot(v, h));\n  ShadingResult result;\n  vec3 r = normalize(reflect(-v, n));\n  RadianceCoeff coeff = getRadianceCoeff(materialInfo, NoV);\n#if USE_LIGHTMAP\n  vec4 lm = texture2D(lightmap, LIGHTMAP_UV);\n  result.f_diffuseIndirect += RGBM2Linear(lm) * materialInfo.c_diffuse * mix(0.5, 1.0, smoothstep(-0.5, 0.0, n.y));\n  result.f_specularIndirect += coeff.k_S * getIBLSpecularRadiance(r, materialInfo.roughness, materialInfo.worldPos);\n#else\n  result.f_diffuseIndirect  += coeff.k_D * getIBLDiffuseRadiance(n, materialInfo.worldPos);\n  result.f_specularIndirect += coeff.k_S * getIBLSpecularRadiance(r, materialInfo.roughness, materialInfo.worldPos);\n#endif\n#if USE_INDIRECTMAP\n  vec4 im = texture2D(indirectmap, INDIRECTMAP_UV);\n  result.f_diffuseIndirect += (im.rgb) * materialInfo.c_diffuse * u_indirectIntensity;\n#endif\n  result.f_emissive += materialInfo.emissive;\n#if USE_SWEEP_LIGHT\n  result.f_emissive += sweepLight(inputParams2.y, inputParams2.z, NoV);\n#endif\n#if USE_PARTICLE\n#if USE_PARTICLE2\n  result.f_specularIndirect = mix(result.f_specularIndirect, result.f_specularIndirect * vec3(4.,8.,8.), smoothstep(0.,0.1,v_progress));\n#else\n  result.f_specularIndirect = mix(result.f_specularIndirect, result.f_specularIndirect * 8., smoothstep(0.,0.1,v_progress));\n#endif\n#endif\n  return result;\n}\nvec4 getStandardOutput(MaterialInfo materialInfo) {\n  ShadingResult result = getStandardShading(materialInfo);\n  vec3 finalColor = result.f_emissive + result.f_diffuse + result.f_specular + (result.f_diffuseIndirect + result.f_specularIndirect) * materialInfo.ao;\n  finalColor = applyFog(finalColor, v_view, v_worldPos) * cc_debug_view_mode.x;\n  return vec4(finalColor, result.alpha);\n}\nvec4 frag() {\n  MaterialInfo materialInfo = getMaterialInfo();\n  return getStandardOutput(materialInfo);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[{"name":"cc_environment","defines":[]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":82,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":64}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_PBR_MAP","type":"boolean"},{"name":"USE_PARTICLE","type":"boolean"},{"name":"USE_PARTICLE2","type":"boolean"},{"name":"USE_LINEAR_COLOR","type":"boolean"},{"name":"USE_OCCLUSION_MAP","type":"boolean"},{"name":"OCCLUSION_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_OCCLUSION_MAP2","type":"boolean"},{"name":"USE_EMISSIVE_MAP","type":"boolean"},{"name":"USE_SCREEN_POS","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"USE_LIGHTMAP","type":"boolean"},{"name":"LIGHTMAP_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_INDIRECTMAP","type":"boolean"},{"name":"INDIRECTMAP_UV","type":"string","options":["v_uv","v_uv1"]},{"name":"USE_SWEEP_LIGHT","type":"boolean"}]}],[{"name":"opaque","passes":[{"program":"../materials/standard|standard-vs:vert|standard-fs:frag","properties":{"mainTexture":{"value":"white","type":28},"mainTexture_ST":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"roughness":{"type":13,"value":[1],"handleInfo":["inputParams",0,13]},"metallic":{"type":13,"value":[0],"handleInfo":["inputParams",1,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["inputParams",2,13]},"occlusionMap":{"value":"white","type":28},"occlusionMap2":{"value":"white","type":28},"emissiveMap":{"value":"black","type":28},"emissive":{"type":13,"value":[1],"handleInfo":["albedoScaleAndCutoff",3,13]},"emissiveColor":{"type":16,"value":[0,0,0,1]},"pbrMap":{"value":"black","type":28},"pbrMap_ST":{"type":16,"value":[1,1,0,0]},"normalMap":{"value":"black","type":28},"normalMap_ST":{"type":16,"value":[1,1,0,0]},"normalScale":{"type":13,"value":[1],"handleInfo":["inputParams",3,13]},"lightmap":{"value":"black","type":28},"indirectmap":{"value":"black","type":28},"indirectIntensity":{"type":13,"value":[1],"handleInfo":["inputParams2",0,13]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,1]},"inputParams":{"type":16,"value":[1,0,1,1]},"inputParams2":{"type":16,"value":[1,0,0,0]}}}]},{"name":"transparent","passes":[{"program":"../materials/standard|standard-vs:vert|standard-fs:frag","embeddedMacros":{"CC_FORCE_FORWARD_SHADING":true},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"mainTexture":{"value":"white","type":28},"mainTexture_ST":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"roughness":{"type":13,"value":[1],"handleInfo":["inputParams",0,13]},"metallic":{"type":13,"value":[0],"handleInfo":["inputParams",1,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["inputParams",2,13]},"occlusionMap":{"value":"white","type":28},"occlusionMap2":{"value":"white","type":28},"emissiveMap":{"value":"black","type":28},"emissive":{"type":13,"value":[1],"handleInfo":["albedoScaleAndCutoff",3,13]},"emissiveColor":{"type":16,"value":[0,0,0,1]},"pbrMap":{"value":"black","type":28},"pbrMap_ST":{"type":16,"value":[1,1,0,0]},"normalMap":{"value":"black","type":28},"normalMap_ST":{"type":16,"value":[1,1,0,0]},"normalScale":{"type":13,"value":[1],"handleInfo":["inputParams",3,13]},"lightmap":{"value":"black","type":28},"indirectmap":{"value":"black","type":28},"indirectIntensity":{"type":13,"value":[1],"handleInfo":["inputParams2",0,13]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,1]},"inputParams":{"type":16,"value":[1,0,1,1]},"inputParams2":{"type":16,"value":[1,0,0,0]}}}]},{"name":"particle","passes":[{"program":"../materials/standard|standard-vs:vert|standard-fs:frag","embeddedMacros":{"USE_PARTICLE":true},"properties":{"mainTexture":{"value":"white","type":28},"mainTexture_ST":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"roughness":{"type":13,"value":[1],"handleInfo":["inputParams",0,13]},"metallic":{"type":13,"value":[0],"handleInfo":["inputParams",1,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["inputParams",2,13]},"occlusionMap":{"value":"white","type":28},"occlusionMap2":{"value":"white","type":28},"emissiveMap":{"value":"black","type":28},"emissive":{"type":13,"value":[1],"handleInfo":["albedoScaleAndCutoff",3,13]},"emissiveColor":{"type":16,"value":[0,0,0,1]},"pbrMap":{"value":"black","type":28},"pbrMap_ST":{"type":16,"value":[1,1,0,0]},"normalMap":{"value":"black","type":28},"normalMap_ST":{"type":16,"value":[1,1,0,0]},"normalScale":{"type":13,"value":[1],"handleInfo":["inputParams",3,13]},"lightmap":{"value":"black","type":28},"indirectmap":{"value":"black","type":28},"indirectIntensity":{"type":13,"value":[1],"handleInfo":["inputParams2",0,13]},"noiseMap":{"value":"black","type":28},"progress":{"type":13,"value":[0],"handleInfo":["inputParams2",3,13]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,1]},"inputParams":{"type":16,"value":[1,0,1,1]},"inputParams2":{"type":16,"value":[1,0,0,0]}}}]},{"name":"particle2","passes":[{"program":"../materials/standard|standard-vs:vert|standard-fs:frag","embeddedMacros":{"USE_PARTICLE2":true},"properties":{"mainTexture":{"value":"white","type":28},"mainTexture_ST":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"roughness":{"type":13,"value":[1],"handleInfo":["inputParams",0,13]},"metallic":{"type":13,"value":[0],"handleInfo":["inputParams",1,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["inputParams",2,13]},"occlusionMap":{"value":"white","type":28},"occlusionMap2":{"value":"white","type":28},"emissiveMap":{"value":"black","type":28},"emissive":{"type":13,"value":[1],"handleInfo":["albedoScaleAndCutoff",3,13]},"emissiveColor":{"type":16,"value":[0,0,0,1]},"pbrMap":{"value":"black","type":28},"pbrMap_ST":{"type":16,"value":[1,1,0,0]},"normalMap":{"value":"black","type":28},"normalMap_ST":{"type":16,"value":[1,1,0,0]},"normalScale":{"type":13,"value":[1],"handleInfo":["inputParams",3,13]},"lightmap":{"value":"black","type":28},"indirectmap":{"value":"black","type":28},"indirectIntensity":{"type":13,"value":[1],"handleInfo":["inputParams2",0,13]},"noiseMap":{"value":"black","type":28},"progress":{"type":13,"value":[0],"handleInfo":["inputParams2",3,13]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,1]},"inputParams":{"type":16,"value":[1,0,1,1]},"inputParams2":{"type":16,"value":[1,0,0,0]}}}]},{"name":"sweeplight","passes":[{"program":"../materials/standard|standard-vs:vert|standard-fs:frag","embeddedMacros":{"USE_PARTICLE":true,"USE_SWEEP_LIGHT":true},"properties":{"mainTexture":{"value":"white","type":28},"mainTexture_ST":{"type":16,"value":[1,1,0,0]},"mainColor":{"type":16,"value":[1,1,1,1]},"albedoScale":{"type":15,"value":[1,1,1],"handleInfo":["albedoScaleAndCutoff",0,15]},"roughness":{"type":13,"value":[1],"handleInfo":["inputParams",0,13]},"metallic":{"type":13,"value":[0],"handleInfo":["inputParams",1,13]},"occlusion":{"type":13,"value":[1],"handleInfo":["inputParams",2,13]},"occlusionMap":{"value":"white","type":28},"occlusionMap2":{"value":"white","type":28},"emissiveMap":{"value":"black","type":28},"emissive":{"type":13,"value":[1],"handleInfo":["albedoScaleAndCutoff",3,13]},"emissiveColor":{"type":16,"value":[0,0,0,1]},"pbrMap":{"value":"black","type":28},"pbrMap_ST":{"type":16,"value":[1,1,0,0]},"normalMap":{"value":"black","type":28},"normalMap_ST":{"type":16,"value":[1,1,0,0]},"normalScale":{"type":13,"value":[1],"handleInfo":["inputParams",3,13]},"lightmap":{"value":"black","type":28},"indirectmap":{"value":"black","type":28},"indirectIntensity":{"type":13,"value":[1],"handleInfo":["inputParams2",0,13]},"noiseMap":{"value":"black","type":28},"progress":{"type":13,"value":[0],"handleInfo":["inputParams2",3,13]},"sweepThreshold":{"type":13,"value":[0],"handleInfo":["inputParams2",1,13]},"sweepIntensity":{"type":13,"value":[0],"handleInfo":["inputParams2",2,13]},"albedoScaleAndCutoff":{"type":16,"value":[1,1,1,1]},"inputParams":{"type":16,"value":[1,0,1,1]},"inputParams2":{"type":16,"value":[1,0,0,0]}}}]}]]],0,0,[],[],[]]]]
