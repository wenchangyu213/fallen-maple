[1,["a3zQCfCrBCDZJ4uf2rk5u8","9cD+BPH8JJjbOi+3cgeffb@6c48a","099TJkzZVHUZmt1RbBZN2A","22aG0Ot7RCo72DrW2zLOTs","2fJyzNKTZDJLfi/tnsp6fP","37ARrCSO1Ee6/No8ENK1xY","37S05NKuBKqJ0MctIrNrn6","46GSwVRmJO2qjPnzoTl1gv","b1bSQuUxdLp431OneabIeu","f8TYKSR/RHl79shUnHv+5X","758YCTCGZNCKjPYBHogdD2","dfsBTIlN1NhqjuumlG8R4V","70Noa4/j1Jz69N4PhIOr5t","676swcn39GpbGzi4qUjiGk","7aaGvCv31HPoSLcNDSDXLq","a604vFVnFHGoF7aroOFD19","705K5Mjk5Hf5t6ZMZ489Hh@e3734","d8yXWzGyZGHKOltah41dBF","baYom81gtHlZHrw+KV5S33@63569","04+fBkmIZCqLhWSvDz40Iq@6c48a","e183UypwhADIBGfcNA4och@6c48a","820RbWj7VOibiFAXA+5ZJs","f59DUL1lRDXqWIYUoz+C1D@6c48a"],["node","_effectAsset","mainTexture","root","_parent","targetInfo","asset","data","_mesh","_cameraComponent","scene","_defaultClip","causticTexture","surfaceWaterDepth"],[["cc.Node",["_name","_id","_objFlags","__editorExtras__","_parent","_components","_lrot","_euler","_prefab","_lpos","_children","_lscale"],-1,1,9,5,5,4,5,9,5],["cc.Node",["_name","_layer","_id","_children","_prefab","_parent","_components","_lpos","_lscale"],0,2,4,1,9,5,5],["cc.Camera",["_fov","_far","_visibility","_projection","_priority","_fovAxis","_orthoHeight","_clearFlags","node","_color"],-5,1,5],["cc.Material",["_name","_states","_defines","_techIdx","_props"],-1,12],["cc.SceneAsset",["_name"],2],["cc.Scene",["_name","_children","_prefab","_globals"],2,2,4,4],["cc.PrefabInfo",["root","asset","fileId","instance","targetOverrides","nestedPrefabInstanceRoots"],-2,2],["cc.PrefabInfo",["fileId","targetOverrides","nestedPrefabInstanceRoots","root","instance","asset"],0,1,4,6],["cc.PrefabInfo",["fileId","instance","targetOverrides","nestedPrefabInstanceRoots","root","asset"],-1,1,1],["cc.SceneGlobals",["ambient","shadows","_skybox","fog","octree","skin","lightProbeInfo","postSettings"],3,4,4,4,4,4,4,4,4],["cc.AmbientInfo",["_skyIllumLDR","_skyColorHDR","_skyColorLDR"],2,5,5],["cc.ShadowsInfo",["_enabled","_type","_maxReceived","_shadowColor"],0,5],["cc.SkyboxInfo",[],3],["cc.FogInfo",["_fogColor"],3,5],["cc.OctreeInfo",[],3],["cc.SkinInfo",[],3],["cc.LightProbeInfo",[],3],["cc.PostSettingsInfo",[],3],["cc.TargetInfo",["localID"],2],["cc.Node",["_name","_parent","_components","_lpos"],2,1,2,5],["a2e47ViUuZJ36JKmr/XnNEB",["node","matNumList"],3,1,3],["cc.UITransform",["node","__prefab","_contentSize"],3,1,4,5],["cc.CompPrefabInfo",["fileId"],2],["cc.Canvas",["node","__prefab","_cameraComponent"],3,1,4,1],["cc.Widget",["_alignFlags","node","__prefab"],2,1,4],["80af6u0E5FEOLF/g/9Soi6u",["node"],3,1],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],1,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,1],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,1,8],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["cc.DirectionalLight",["_colorTemperature","_illuminanceHDR","_illuminanceLDR","_shadowEnabled","_shadowPcf","_shadowSaturation","_shadowDistance","_shadowFixedArea","_shadowFar","_shadowOrthoSize","node","_staticSettings"],-7,1,4],["cc.StaticLightSettings",[],3],["554baRvdXVCaZZeXFSvvApe",["node"],3,1],["cc.Prefab",["_name"],2],["cc.MeshRenderer",["node","__prefab","_materials","bakeSettings","_mesh"],3,1,4,3,4,6],["cc.ModelBakeSettings",[],3],["cc.Animation",["node","__prefab","_clips","_defaultClip"],3,1,4,3,6],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[3,0,1,2,4,4],[22,0,2],[8,0,1,2,3,4,5,5],[28,0,1,2,2],[18,0,2],[0,0,4,2],[27,0,1,2,3],[7,0,1,2,3,4,5,4],[0,2,3,4,8,3],[26,0,1,2,3],[33,0,2],[34,0,1,2,3,4,1],[35,1],[37,0,1,2,3],[4,0,2],[5,0,1,2,3,2],[6,0,1,2,3,4,5,6],[9,0,1,2,3,4,5,6,7,1],[10,0,1,2,2],[11,0,1,2,3,4],[12,1],[13,0,1],[14,1],[15,1],[16,1],[17,1],[0,0,1,4,10,5,3],[0,0,1,4,5,9,6,7,3],[0,0,2,1,4,5,9,6,7,4],[0,0,1,4,5,3],[0,0,4,5,8,6,7,2],[0,0,4,5,8,6,11,7,2],[1,0,1,2,5,3,6,7,4],[1,0,3,4,7,8,2],[1,0,5,3,4,2],[1,0,3,6,4,8,2],[19,0,1,2,3,2],[20,0,1,1],[21,0,1,2,1],[23,0,1,2,1],[24,0,1,2,2],[2,0,1,2,8,4],[2,3,4,0,5,6,1,7,2,8,9,9],[25,0,1],[29,0,1,2,3],[30,0,1,2,3,4,5,6,7,8,9,10,11,11],[31,1],[32,0,1],[36,0,1,2,3,1],[3,0,3,1,2,4,5],[38,0,1,2,4]],[[[[14,"main"],[15,"main",[-3,-4,-5,-6,-7,-8,-9],[16,null,null,"174e3204-1c36-4356-a9a5-3b536ce7e340",null,null,[-1,-2]],[17,[18,0.78125,[2,0.2,0.5019607843137255,0.8,0.520833125],[2,0.2,0.5019607843137255,0.8,0.520833125]],[19,true,1,1,[4,2684354560]],[20],[21,[4,4292993505]],[22],[23],[24],[25]]],[4,["9123rn+B5G04H76Lvir3Tt"]],[26,"gameManager","af6OAvNaRAio6s8xqJlG+S",1,[[5,"map",-11],[5,"brickFloor",-12],[5,"rewardCircle",-13]],[[37,-10,[2,3,4,5,6,7,8,9,10,11]]]],[32,"Canvas",33554432,"b4EtK3gXRPTIlfrJRV4TeX",1,[-18],[[38,-14,[1,"0dngp/9gNO34wUQjZfN/CX"],[5,720,1280]],[39,-16,[1,"3f2oTdCepERZdpmIfLsrhd"],-15],[40,45,-17,[1,"e8a+bU/8dPDbbJguUzLdoF"]]],[1,360,640,0]],[27,"Main Camera","c9DMICJLFO5IeO07EPon7U",1,[[41,50,150,1822425087,-19],[43,-20]],[1,0,1.1,2.2],[3,-0.17364817766693033,2.4098525628753244e-18,-1.3666953027793971e-17,0.984807753012208],[1,-20,0,-1.5902773407317584e-15]],[8,512,{},1,[7,"9123rn+B5G04H76Lvir3Tt",null,null,-21,[9,"38vUDdkZtK5ZnIZh3YkIba",null,[[6,true,["active"],2],[3,["rotation"],2,[3,0,0,0,1]],[3,["scale"],2,[1,20,20,20]],[6,1073741824,["layer"],2],[3,["_lpos"],2,[1,0,-0.3,0]]]],0]],[8,0,{},1,[7,"8450jVdZ1GuofCIsQJ4x1/",null,null,-24,[9,"e5MN8nX5VDv4kwXlYRFM3+",null,[[6,true,["active"],-22],[44,true,["playOnLoad"],[4,["a5aO1pAzBEOZ8R2Ne3p4HU"]]],[3,["_lpos"],-23,[1,0,-0.3,0]]]],1]],[28,"Main Light",512,"c0y6F5f+pAvI805TdmxIjx",1,[[45,7500,100000,3.125,true,2,0.627451,100,true,30,1,-25,[46]]],[1,4.997,7.298,4.297],[3,-0.3535533905932738,0.3535533905932738,0.14644660940672624,0.8535533905932737],[1,-45,45,0]],[4,["8450jVdZ1GuofCIsQJ4x1/"]],[36,"Camera",4,[-26],[1,0,0,1000]],[42,0,1073741824,36.11111111111111,1,640,2000,6,41943040,10,[4,4278190080]],[29,"effectManager","3bUPE3AC5FtKeQKSa0AMx9",1,[[47,-27]]]],0,[0,-1,6,0,-2,7,0,-1,8,0,-2,5,0,-3,6,0,-4,7,0,-5,3,0,-6,4,0,-7,12,0,0,3,0,4,3,0,4,3,0,4,3,0,0,4,0,9,11,0,0,4,0,0,4,0,-1,10,0,0,5,0,0,5,0,3,6,0,5,9,0,5,9,0,3,7,0,0,8,0,-1,11,0,0,12,0,10,1,27],[0,0,0,0,0,0,0,0,0,0,0,0],[6,6,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10],[3,4,5,6,7,8,9,10,11,12,13,14]],[[[10,"waterPlane"],[33,"waterPlane",[-2],[2,"9123rn+B5G04H76Lvir3Tt",null,null,null,-1,0],[1,0,-1,0],[1,20,20,20]],[34,"RootNode",1,[-3],[2,"b5GjP73bBG36/DbssrSzyG",null,null,null,1,0]],[30,"waterPlane",2,[[11,-4,[1,"1by20MZeFA2ZehuPa6wiUj"],[0],[12],1]],[2,"f9FaFDPPNEg54ByCOM+/De",null,null,null,1,0],[3,-0.7071067811865476,0,0,0.7071067811865476],[1,-90.00000000000003,0,0]]],0,[0,3,1,0,-1,2,0,-1,3,0,0,3,0,7,1,4],[0,0],[-1,8],[15,16]],[[[10,"skyBox"],[35,"skyBox",[-3],[[48,-2,[1,"a5aO1pAzBEOZ8R2Ne3p4HU"],[2],3]],[2,"8450jVdZ1GuofCIsQJ4x1/",null,null,null,-1,0],[1,20,20,20]],[31,"skyBox",1,[[11,-4,[1,"f4bm6zrYJFZrjY1uGAuUhM"],[0],[12],1]],[2,"b0AdKmkaFFz7Sl7cWtEkoW",null,null,null,1,0],[3,-0.7071067811865477,0,0,0.7071067811865474],[1,0.034,0.034,0.034],[1,-90.00000000000003,0,0]]],0,[0,3,1,0,0,1,0,-1,2,0,0,2,0,7,1,4],[0,0,0,0],[-1,8,-1,11],[17,18,2,2]],[[[49,"plane02",1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"tilingOffset",8,[2,0.1,1,0,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,"num2",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.2,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,"num8",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.8,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,"num7",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.7,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[13,".bin",2851593682,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":192,"length":12,"count":6,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":192,"count":4,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-5,-5,0],"maxPosition",8,[1,5,5,0]]],-1],0,0,[],[],[]],[[[0,"num5",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.5,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,"num9",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.9,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[50,"../res/model/map/water/newwater/water",[{"hash":2402277427,"name":"../res/model/map/water/newwater/water|water-vs:vert|water-fs:frag","blocks":[{"name":"Light","stageFlags":17,"binding":0,"members":[{"name":"pbrParams","type":16,"count":1}],"defines":["USE_LIGHT"]},{"name":"Water","stageFlags":17,"binding":1,"members":[{"name":"normalParams","type":16,"count":1},{"name":"shallowColor","type":16,"count":1},{"name":"deepColor","type":16,"count":1},{"name":"waveVisuals","type":16,"count":1},{"name":"waveDirections","type":16,"count":1},{"name":"foamParams","type":16,"count":1},{"name":"foamColor","type":16,"count":1},{"name":"causticParams1","type":16,"count":1},{"name":"causticParams2","type":16,"count":1},{"name":"depthDistance","type":13,"count":1},{"name":"opacity","type":13,"count":1},{"name":"coastOpacity","type":13,"count":1}],"defines":[]},{"name":"FsConstant","stageFlags":16,"binding":2,"members":[{"name":"depthGradientShallow","type":16,"count":1},{"name":"depthGradientDeep","type":16,"count":1},{"name":"depthMaxDistance","type":13,"count":1}],"defines":["USE_DEPTH"]}],"samplerTextures":[{"name":"foamTexture","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":3,"defines":["USE_FOAM"]},{"name":"causticTexture","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":4,"defines":["USE_CAUSTIC"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":5,"defines":["USE_NORMAL_MAP"]},{"name":"surfaceWaterDepth","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":6,"defines":["USE_DEPTH"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_reflectionProbeData","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_REFLECTION_PROBE"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":15,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":16,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeBlendData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_INSTANCING"]},{"name":"CCSH","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_sh_linear_const_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_linear_const_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_r","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_g","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_b","typename":"vec4","type":16,"count":1},{"name":"cc_sh_quadratic_a","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]},{"name":"CCForwardLight","stageFlags":16,"tags":{"builtin":"local"},"members":[{"name":"cc_lightPos","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true},{"name":"cc_lightColor","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightSizeRangeAngle","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightDir","typename":"vec4","type":16,"count":0,"isArray":true},{"name":"cc_lightBoundingSizeVS","typename":"vec4","type":16,"count":0,"isArray":true}],"defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","typename":"sampler2D","type":28,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"local"},"defines":["CC_USE_REFLECTION_PROBE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"Light","stageFlags":17,"binding":0,"members":[{"name":"pbrParams","type":16,"count":1}],"defines":["USE_LIGHT"]},{"name":"Water","stageFlags":17,"binding":1,"members":[{"name":"normalParams","type":16,"count":1},{"name":"shallowColor","type":16,"count":1},{"name":"deepColor","type":16,"count":1},{"name":"waveVisuals","type":16,"count":1},{"name":"waveDirections","type":16,"count":1},{"name":"foamParams","type":16,"count":1},{"name":"foamColor","type":16,"count":1},{"name":"causticParams1","type":16,"count":1},{"name":"causticParams2","type":16,"count":1},{"name":"depthDistance","type":13,"count":1},{"name":"opacity","type":13,"count":1},{"name":"coastOpacity","type":13,"count":1}],"defines":[]},{"name":"FsConstant","stageFlags":16,"binding":2,"members":[{"name":"depthGradientShallow","type":16,"count":1},{"name":"depthGradientDeep","type":16,"count":1},{"name":"depthMaxDistance","type":13,"count":1}],"defines":["USE_DEPTH"]}],"samplerTextures":[{"name":"foamTexture","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":3,"defines":["USE_FOAM"]},{"name":"causticTexture","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":4,"defines":["USE_CAUSTIC"]},{"name":"normalMap","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":5,"defines":["USE_NORMAL_MAP"]},{"name":"surfaceWaterDepth","type":28,"count":1,"stageFlags":16,"sampleType":0,"binding":6,"defines":["USE_DEPTH"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCShadow","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matLightView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matLightViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_shadowInvProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjDepthInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowProjInfo","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_shadowNFLSInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowWHPBInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowLPNNInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_shadowColor","typename":"vec4","type":16,"count":1,"precision":"lowp "},{"name":"cc_planarNDInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCSM","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_csmViewDir0","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir1","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmViewDir2","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmAtlas","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_matCSMViewProj","typename":"mat4","type":25,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjDepthInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmProjInfo","typename":"vec4","type":16,"count":4,"precision":"highp ","isArray":true},{"name":"cc_csmSplitsInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":17,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"global"},"defines":[]},{"name":"cc_diffuseMap","typename":"samplerCube","type":31,"count":1,"stageFlags":16,"sampleType":0,"tags":{"builtin":"global"},"defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl1":{"vert":"\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE\n    attribute vec4 a_reflectionProbeData;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nuniform highp vec4 cc_time;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    vec3 scale = 1.0 / vec3(length(a_matWorld0.xyz), length(a_matWorld1.xyz), length(a_matWorld2.xyz));\n    vec3 scale2 = scale * scale;\n    matWorldIT = mat4(\n      vec4(a_matWorld0.xyz * scale2.x, 0.0),\n      vec4(a_matWorld1.xyz * scale2.y, 0.0),\n      vec4(a_matWorld2.xyz * scale2.z, 0.0),\n      vec4(0.0, 0.0, 0.0, 1.0)\n    );\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#if USE_LIGHT\n#endif\n   uniform vec4 waveVisuals;\n   uniform vec4 waveDirections;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\n#if CC_RECEIVE_SHADOW\n#endif\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_TRANSFER_FOG(vec4 pos) {\n#if !CC_USE_ACCURATE_FOG\n    CC_TRANSFER_FOG_BASE(pos, v_fog_factor);\n#endif\n}\nvarying vec3 v_position;\nvarying vec4 v_projPos;\nvarying vec2 v_uv;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nvec3 gerstner(vec3 position, float steepness, float wavelength, float speed, float direction, inout vec3 tangent, inout vec3 binormal)\n{\n  direction = direction * 2. - 1.;\n  vec2 d = normalize(vec2(cos(3.14 * direction), sin(3.14 * direction)));\n  float s = steepness;\n  float k = 2. * 3.14 / wavelength;\n  float f = k * (dot(d, position.xz) - speed * cc_time.x);\n  float a = s / k;\n  tangent += vec3(\n    -d.x * d.x * s * sin(f),\n    d.x * s * cos(f),\n    -d.x * d.y * s * sin(f)\n  );\n  binormal += vec3(\n    -d.x * d.y * s * sin(f),\n    d.y * s * cos(f),\n    -d.y * d.y * s * sin(f)\n  );\n  return vec3(\n    d.x * a * cos(f),\n    a * sin(f),\n    d.y * a * cos(f)\n  );\n}\nvoid gerstnerWaves(vec3 p, vec3 visuals, vec4 directions, out vec3 offset, out vec3 normal, out vec3 T, out vec3 B)\n{\n    float steepness = visuals.x ;\n    float wavelength = visuals.y;\n    float speed = visuals.z;\n    offset = vec3(0,0,0);\n    vec3 tangent = vec3(1, 0, 0);\n    vec3 binormal = vec3(0, 0, 1);\n    offset += gerstner(p, steepness, wavelength, speed, directions.x, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.y, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.z, tangent, binormal);\n    offset += gerstner(p, steepness, wavelength, speed, directions.w, tangent, binormal);\n    normal = normalize(cross(binormal, tangent));\n    T = tangent;\n    B = binormal;\n}\nvec4 vert () {\n  StandardVertInput In;\n  CCVertInput(In);\n  mat4 matWorld, matWorldIT;\n  CCGetWorldMatrixFull(matWorld, matWorldIT);\n  vec4 worldPos = matWorld * In.position;\n  #if USE_WAVE\n    vec3 offset;\n    vec3 tangent;\n    vec3 bitangent;\n    gerstnerWaves(worldPos.xyz, waveVisuals.xyz, waveDirections, offset, v_normal, tangent, bitangent);\n    worldPos.xyz += offset;\n    #if USE_NORMAL_MAP\n      v_tangent = tangent;\n      v_bitangent = bitangent;\n    #endif\n  #endif\n  v_position = worldPos.xyz;\n  v_projPos = cc_matProj * cc_matView * worldPos;\n  #if !USE_WAVE\n    v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n    #if USE_NORMAL_MAP\n      v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n      v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n    #endif\n  #endif\n  v_uv = a_texCoord;\n  CC_TRANSFER_FOG(worldPos);\n  v_shadowPos = cc_matLightViewProj * worldPos;\n  return v_projPos;\n}\nvoid main() { gl_Position = vert(); }","frag":"\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_time;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogColor;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define REFLECTION_PROBE_TYPE_BLEND 3\n#define REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX 4\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_SPHERE 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_POINT 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\n#ifndef CC_SURFACES_DEBUG_VIEW_SINGLE\n  #define CC_SURFACES_DEBUG_VIEW_SINGLE 1\n#endif\n#ifndef CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC\n  #define CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC 2\n#endif\nvec3 LinearToSRGB(vec3 linear) {\n#ifdef CC_USE_SURFACE_SHADER\n  #if CC_USE_DEBUG_VIEW == CC_SURFACES_DEBUG_VIEW_COMPOSITE_AND_MISC && CC_SURFACES_ENABLE_DEBUG_VIEW\n    if (!IS_DEBUG_VIEW_COMPOSITE_ENABLE_GAMMA_CORRECTION) {\n      return linear;\n    }\n  #endif\n#endif\n  return sqrt(linear);\n}\n#if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #endif\n#if defined(CC_USE_METAL) || defined(CC_USE_WGPU)\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y) y = -y\n#else\n#define CC_HANDLE_SAMPLE_NDC_FLIP_STATIC(y)\n#endif\n#if CC_RECEIVE_SHADOW\n  uniform highp sampler2D cc_shadowMap;\n  uniform highp sampler2D cc_spotShadowMap;\n    #define UnpackBitFromFloat(value, bit) (mod(floor(value / pow(10.0, float(bit))), 10.0) > 0.0)\n  #if CC_SUPPORT_CASCADED_SHADOW_MAP\n  #else\n  #endif\n#endif\nvec4 packRGBE (vec3 rgb) {\n  highp float maxComp = max(max(rgb.r, rgb.g), rgb.b);\n  highp float e = 128.0;\n  if (maxComp > 0.0001) {\n    e = log(maxComp) / log(1.1);\n    e = ceil(e);\n    e = clamp(e + 128.0, 0.0, 255.0);\n  }\n  highp float sc = 1.0 / pow(1.1, e - 128.0);\n  vec3 encode = clamp(rgb * sc, vec3(0.0), vec3(1.0)) * 255.0;\n  vec3 encode_rounded = floor(encode) + step(encode - floor(encode), vec3(0.5));\n  return vec4(encode_rounded, e) / 255.0;\n}\nuniform samplerCube cc_environment;\n#if CC_USE_IBL\n  #if CC_USE_DIFFUSEMAP\n    uniform samplerCube cc_diffuseMap;\n  #endif\n#endif\n#if CC_USE_REFLECTION_PROBE\n  uniform samplerCube cc_reflectionProbeCubemap;\n  uniform sampler2D cc_reflectionProbePlanarMap;\n  uniform sampler2D cc_reflectionProbeDataMap;\n  #endif\n#if CC_USE_LIGHT_PROBE\n#if CC_USE_LIGHT_PROBE\n  #if USE_INSTANCING\n    varying mediump vec4 v_sh_linear_const_r;\n    varying mediump vec4 v_sh_linear_const_g;\n    varying mediump vec4 v_sh_linear_const_b;\n  #else\n    #endif\n  #if CC_USE_LIGHT_PROBE\n  #endif\n#endif\n#endif\n#if USE_REFLECTION_DENOISE\n#endif\nstruct StandardSurface {\n  vec4 albedo;\n    #if CC_PLATFORM_ANDROID_AND_WEBGL && CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES\n    vec3 position, position_fract_part;\n    #else\n    vec3 position;\n    #endif\n  vec3 normal;\n  vec3 emissive;\n  vec4 lightmap;\n  float lightmap_test;\n  float roughness;\n  float metallic;\n  float occlusion;\n  float specularIntensity;\n  #if CC_RECEIVE_SHADOW\n    vec2 shadowBias;\n  #endif\n  #if CC_RECEIVE_SHADOW || CC_USE_REFLECTION_PROBE\n    float reflectionProbeId;\n  #endif\n  #if CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND || CC_USE_REFLECTION_PROBE == REFLECTION_PROBE_TYPE_BLEND_AND_SKYBOX\n    float reflectionProbeBlendId;\n    float reflectionProbeBlendFactor;\n  #endif\n};\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n  #define LIGHTS_PER_PASS 1\n#else\n  #define LIGHTS_PER_PASS 10\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n#endif\n#if CC_ENABLE_CLUSTERED_LIGHT_CULLING == 0\n#endif\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_RGBE_OUTPUT\n    color = packRGBE(color.rgb);\n  #elif !CC_USE_FLOAT_OUTPUT\n    #if CC_USE_HDR && CC_TONE_MAPPING_TYPE == HDR_TONE_MAPPING_ACES\n      color.rgb = ACESToneMap(color.rgb);\n    #endif\n    color.rgb = LinearToSRGB(color.rgb);\n  #endif\n  return color;\n}\n#if USE_LIGHT\n  uniform vec4 pbrParams;\n#endif\n   uniform vec4 normalParams;\n   uniform vec4 shallowColor;\n   uniform vec4 causticParams1;\n   uniform vec4 causticParams2;\n#if CC_USE_FOG != 4\n  float LinearFog(vec4 pos, vec3 cameraPos, float fogStart, float fogEnd) {\n      vec4 wPos = pos;\n      float cam_dis = distance(cameraPos, wPos.xyz);\n      return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n  }\n  float ExpFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * fogDensity);\n      return f;\n  }\n  float ExpSquaredFog(vec4 pos, vec3 cameraPos, float fogStart, float fogDensity, float fogAtten) {\n      vec4 wPos = pos;\n      float cam_dis = max(distance(cameraPos, wPos.xyz) - fogStart, 0.0) / fogAtten * 4.;\n      float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n      return f;\n  }\n  float LayeredFog(vec4 pos, vec3 cameraPos, float fogTop, float fogRange, float fogAtten) {\n      vec4 wPos = pos;\n      vec3 camWorldProj = cameraPos.xyz;\n      camWorldProj.y = 0.;\n      vec3 worldPosProj = wPos.xyz;\n      worldPosProj.y = 0.;\n      float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n      float fDeltaY, fDensityIntegral;\n      if (cameraPos.y > fogTop) {\n          if (wPos.y < fogTop) {\n              fDeltaY = (fogTop - wPos.y) / fogRange * 2.0;\n              fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n          }\n          else {\n              fDeltaY = 0.;\n              fDensityIntegral = 0.;\n          }\n      }\n      else {\n          if (wPos.y < fogTop) {\n              float fDeltaA = (fogTop - cameraPos.y) / fogRange * 2.;\n              float fDeltaB = (fogTop - wPos.y) / fogRange * 2.;\n              fDeltaY = abs(fDeltaA - fDeltaB);\n              fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n          }\n          else {\n              fDeltaY = abs(fogTop - cameraPos.y) / fogRange * 2.;\n              fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n          }\n      }\n      float fDensity;\n      if (fDeltaY != 0.) {\n          fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n      }\n      else {\n          fDensity = 0.;\n      }\n      float f = exp(-fDensity);\n      return f;\n  }\n#endif\nvoid CC_TRANSFER_FOG_BASE(vec4 pos, out float factor)\n{\n#if CC_USE_FOG == 0\n\tfactor = LinearFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.y);\n#elif CC_USE_FOG == 1\n\tfactor = ExpFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 2\n\tfactor = ExpSquaredFog(pos, cc_cameraPos.xyz, cc_fogBase.x, cc_fogBase.z, cc_fogAdd.z);\n#elif CC_USE_FOG == 3\n\tfactor = LayeredFog(pos, cc_cameraPos.xyz, cc_fogAdd.x, cc_fogAdd.y, cc_fogAdd.z);\n#else\n\tfactor = 1.0;\n#endif\n}\nvoid CC_APPLY_FOG_BASE(inout vec4 color, float factor) {\n\tcolor = vec4(mix(cc_fogColor.rgb, color.rgb, factor), color.a);\n}\n#if !CC_USE_ACCURATE_FOG\nvarying mediump float v_fog_factor;\n#endif\nvoid CC_APPLY_FOG(inout vec4 color) {\n#if !CC_USE_ACCURATE_FOG\n    CC_APPLY_FOG_BASE(color, v_fog_factor);\n#endif\n}\nvoid CC_APPLY_FOG(inout vec4 color, vec3 worldPos) {\n#if CC_USE_ACCURATE_FOG\n    float factor;\n    CC_TRANSFER_FOG_BASE(vec4(worldPos, 1.0), factor);\n#else\n    float factor = v_fog_factor;\n#endif\n    CC_APPLY_FOG_BASE(color, factor);\n}\nvarying vec3 v_position;\nvarying vec4 v_projPos;\nvarying vec2 v_uv;\nvarying vec3 v_normal;\n#if USE_FOAM\nuniform sampler2D foamTexture;\n#endif\n#if USE_CAUSTIC\nuniform sampler2D causticTexture;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_DEPTH\n      uniform vec4 depthGradientShallow;\n    uniform vec4 depthGradientDeep;\n    uniform float depthMaxDistance;\n  uniform sampler2D surfaceWaterDepth;\n#endif\nvec3 normalBlend(vec3 A, vec3 B)\n{\n  return normalize(vec3(A.rg + B.rg, A.b * B.b));\n}\n#if USE_CAUSTIC\nvec2 panner(vec2 uv, float direction, float speed, vec2 offset, float tiling)\n{\n    direction = direction * 2. - 1.;\n    vec2 dir = normalize(vec2(cos(3.14 * direction), sin(3.14 * direction)));\n    return  (dir * cc_time.x * speed) + offset + (uv * tiling);\n}\nvec3 rgbSplit(float split, sampler2D tex, vec2 uv)\n{\n    vec2 UVR = uv + vec2(split, split);\n    vec2 UVG = uv + vec2(split, -split);\n    vec2 UVB = uv + vec2(-split, -split);\n    float r = texture2D(tex, UVR).r;\n    float g = texture2D(tex, UVG).g;\n    float b = texture2D(tex, UVB).b;\n    return vec3(r,g,b);\n}\nvec3 caustic()\n{\n  vec2 uv = v_position.xz;\n  float strength = causticParams1.x;\n  float split = causticParams1.w * 0.01;\n  float speed = causticParams1.z;\n  float scale = causticParams1.y;\n  vec3 texture1 = rgbSplit(split, causticTexture, panner(uv, 1., speed, vec2(0., 0.), 1./scale));\n  vec3 texture2 = rgbSplit(split, causticTexture, panner(uv, 1., speed, vec2(0., 0.), -1./scale));\n  vec3 textureCombined = min(texture1, texture2);\n  return strength * 10. * textureCombined;\n}\n#endif\n  vec4 alphaBlend(vec4 top, vec4 bottom)\n{\n  vec3 color = (top.rgb * top.a) + (bottom.rgb * (1. - top.a));\n  float alpha = top.a + bottom.a * (1. - top.a);\n  return vec4(color, alpha);\n}\n#if USE_LIGHT\nvec4 surf (vec4 albedo) {\n  StandardSurface s;\n  s.albedo = albedo;\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    float normalStrenth = normalParams.x;\n    vec2 normalUV = v_uv * normalParams.y;\n    vec2 moveUV = normalUV + normalParams.zw * cc_time.x / 40.;\n    vec3 nmmp = normalBlend(texture2D(normalMap, moveUV).xyz - vec3(.5), texture2D(normalMap, normalUV).xyz - vec3(.5));\n    s.normal =\n      (nmmp.x * normalStrenth) * normalize(v_tangent) +\n      (nmmp.y * normalStrenth) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.specularIntensity = 0.5;\n  s.metallic = pbr.z;\n  return albedo;\n}\n#endif\nvec4 frag () {\n  vec4 waterColor = shallowColor;\n  vec4 finalFoamColor = vec4(0.);\n  #if USE_FOAM\n  #endif\n  vec4 finalCausticColor = vec4(0.);\n  #if USE_CAUSTIC\n    float causticDepth = causticParams2.x;\n    vec3 causticColor = causticParams2.yzw;\n    finalCausticColor.rgb = caustic() * causticColor;\n  #endif\n  #if USE_DEPTH\n    float waterDepth = texture2D(surfaceWaterDepth, v_uv).r;\n    float depth = clamp(1. - waterDepth / depthMaxDistance, 0., 1.);\n    vec4 depthColor = mix(depthGradientShallow, depthGradientDeep, depth);\n    waterColor = alphaBlend(depthColor, waterColor);\n  #endif\n  vec4 finalColor = waterColor + finalFoamColor + finalCausticColor;\n  CC_APPLY_FOG(finalColor);\n  #if USE_LIGHT\n  surf(finalColor);\n  finalColor = CCFragOutput(finalColor);\n  #endif\n  return finalColor;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]},{"name":"CCCSM","defines":["CC_SUPPORT_CASCADED_SHADOW_MAP"]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotShadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_environment","defines":[]},{"name":"cc_diffuseMap","defines":["CC_USE_IBL","CC_USE_DIFFUSEMAP"]}],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_INSTANCING"]},{"name":"CCSH","defines":["CC_USE_LIGHT_PROBE","!USE_INSTANCING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD","CC_ENABLE_CLUSTERED_LIGHT_CULLING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_reflectionProbeCubemap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbePlanarMap","defines":["CC_USE_REFLECTION_PROBE"]},{"name":"cc_reflectionProbeDataMap","defines":["CC_USE_REFLECTION_PROBE"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":144,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":136}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"number","range":[0,3]},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean","default":0},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"USE_LIGHT","type":"boolean"},{"name":"CC_SUPPORT_CASCADED_SHADOW_MAP","type":"boolean"},{"name":"CC_USE_FOG","type":"number","range":[0,4]},{"name":"CC_USE_ACCURATE_FOG","type":"boolean"},{"name":"USE_NORMAL_MAP","type":"boolean"},{"name":"USE_WAVE","type":"boolean"},{"name":"CC_USE_DEBUG_VIEW","type":"number","range":[0,3]},{"name":"CC_SURFACES_ENABLE_DEBUG_VIEW","type":"boolean"},{"name":"CC_USE_IBL","type":"number","range":[0,2]},{"name":"CC_USE_DIFFUSEMAP","type":"number","range":[0,2]},{"name":"USE_REFLECTION_DENOISE","type":"boolean"},{"name":"CC_FORWARD_ADD","type":"boolean"},{"name":"CC_PIPELINE_TYPE","type":"number","range":[0,1]},{"name":"CC_FORCE_FORWARD_SHADING","type":"boolean"},{"name":"CC_ENABLE_CLUSTERED_LIGHT_CULLING","type":"number","range":[0,3]},{"name":"CC_USE_RGBE_OUTPUT","type":"boolean"},{"name":"CC_USE_FLOAT_OUTPUT","type":"boolean"},{"name":"CC_USE_HDR","type":"boolean"},{"name":"CC_TONE_MAPPING_TYPE","type":"number","range":[0,3]},{"name":"HDR_TONE_MAPPING_ACES","type":"boolean"},{"name":"USE_FOAM","type":"boolean"},{"name":"USE_CAUSTIC","type":"boolean"},{"name":"USE_DEPTH","type":"boolean"}]}],[{"name":"opaque","passes":[{"program":"../res/model/map/water/newwater/water|water-vs:vert|water-fs:frag","properties":{"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.1],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[0.5],"handleInfo":["normalParams",0,13]},"normalTile":{"type":13,"value":[1],"handleInfo":["normalParams",1,13]},"normalSpeed":{"type":14,"value":[1,0],"handleInfo":["normalParams",2,14]},"normalMap":{"value":"normal","type":28},"shallowColor":{"type":16,"value":[1,1,1,1]},"deepColor":{"type":16,"value":[0,0,0,0]},"foamColor":{"type":16,"value":[1,1,1,1]},"foamDistance":{"type":13,"value":[0.35],"handleInfo":["foamParams",0,13]},"foamDensity":{"type":13,"value":[0.5],"handleInfo":["foamParams",1,13]},"foamTile":{"type":13,"value":[1],"handleInfo":["foamParams",2,13]},"foamContrast":{"type":13,"value":[0.5],"handleInfo":["foamParams",3,13]},"waveVisuals":{"type":16,"value":[0.167,7,0.54,1]},"waveDirections":{"type":16,"value":[0,0.3,0.6,0.67]},"causticStrength":{"type":13,"value":[0.98],"handleInfo":["causticParams1",0,13]},"causticScale":{"type":13,"value":[2.33],"handleInfo":["causticParams1",1,13]},"causticSpeed":{"type":13,"value":[0.1],"handleInfo":["causticParams1",2,13]},"causticRGBSplit":{"type":13,"value":[0.35],"handleInfo":["causticParams1",3,13]},"causticDepth":{"type":13,"value":[1],"handleInfo":["causticParams2",0,13]},"causticColor":{"type":15,"value":[1,1,1],"handleInfo":["causticParams2",1,15]},"causticTexture":{"value":"white","type":28},"surfaceWaterDepth":{"value":"white","type":28},"depthGradientShallow":{"type":16,"value":[0.325,0.807,0.971,0.725]},"depthGradientDeep":{"type":16,"value":[0.086,0.407,1,0.749]},"depthMaxDistance":{"type":13,"value":[1]},"pbrParams":{"type":16,"value":[1,0.1,0,0]},"normalParams":{"type":16,"value":[0.5,1,1,0]},"foamParams":{"type":16,"value":[0.35,0.5,1,0.5]},"causticParams1":{"type":16,"value":[0.98,2.33,0.1,0.35]},"causticParams2":{"type":16,"value":[1,1,1,1]}}}]},{"name":"transparent","passes":[{"program":"../res/model/map/water/newwater/water|water-vs:vert|water-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"occlusion":{"type":13,"value":[1],"handleInfo":["pbrParams",0,13]},"roughness":{"type":13,"value":[0.1],"handleInfo":["pbrParams",1,13]},"metallic":{"type":13,"value":[0],"handleInfo":["pbrParams",2,13]},"normalStrenth":{"type":13,"value":[0.5],"handleInfo":["normalParams",0,13]},"normalTile":{"type":13,"value":[1],"handleInfo":["normalParams",1,13]},"normalSpeed":{"type":14,"value":[1,0],"handleInfo":["normalParams",2,14]},"normalMap":{"value":"normal","type":28},"shallowColor":{"type":16,"value":[1,1,1,1]},"deepColor":{"type":16,"value":[0,0,0,0]},"foamColor":{"type":16,"value":[1,1,1,1]},"foamDistance":{"type":13,"value":[0.35],"handleInfo":["foamParams",0,13]},"foamDensity":{"type":13,"value":[0.5],"handleInfo":["foamParams",1,13]},"foamTile":{"type":13,"value":[1],"handleInfo":["foamParams",2,13]},"foamContrast":{"type":13,"value":[0.5],"handleInfo":["foamParams",3,13]},"waveVisuals":{"type":16,"value":[0.167,7,0.54,1]},"waveDirections":{"type":16,"value":[0,0.3,0.6,0.67]},"causticStrength":{"type":13,"value":[0.98],"handleInfo":["causticParams1",0,13]},"causticScale":{"type":13,"value":[2.33],"handleInfo":["causticParams1",1,13]},"causticSpeed":{"type":13,"value":[0.1],"handleInfo":["causticParams1",2,13]},"causticRGBSplit":{"type":13,"value":[0.35],"handleInfo":["causticParams1",3,13]},"causticDepth":{"type":13,"value":[1],"handleInfo":["causticParams2",0,13]},"causticColor":{"type":15,"value":[1,1,1],"handleInfo":["causticParams2",1,15]},"causticTexture":{"value":"white","type":28},"surfaceWaterDepth":{"value":"white","type":28},"depthGradientShallow":{"type":16,"value":[0.325,0.807,0.971,0.725]},"depthGradientDeep":{"type":16,"value":[0.086,0.407,1,0.749]},"depthMaxDistance":{"type":13,"value":[1]},"pbrParams":{"type":16,"value":[1,0.1,0,0]},"normalParams":{"type":16,"value":[0.5,1,1,0]},"foamParams":{"type":16,"value":[0.35,0.5,1,0.5]},"causticParams1":{"type":16,"value":[0.98,2.33,0.1,0.35]},"causticParams2":{"type":16,"value":[1,1,1,1]}}}]}]]],0,0,[],[],[]],[[[0,"water",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_WAVE":true,"USE_FOAM":true,"USE_CAUSTIC":true,"USE_DEPTH":true}],[[[{"normalStrenth":1,"opacity":0.5,"causticStrength":0.2,"causticScale":5,"causticSpeed":0.03,"causticRGBSplit":0.6},"shallowColor",8,[4,4294945300],"waveVisuals",8,[2,0.05,7,0.1,1],"causticColor",8,[4,4284436480],"depthGradientShallow",8,[4,3103652024],"depthGradientDeep",8,[4,3202979072],"causticTexture",6,0,"surfaceWaterDepth",6,1]],11]]],0,0,[0,0,0],[12,13,1],[19,20,21]],[[[0,"num3",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.3,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[13,".bin",3144817543,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":26832,"length":5760,"count":2880,"stride":2}}],"vertexBundles":[{"view":{"offset":0,"length":26832,"count":559,"stride":48},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false}]}]},"minPosition",8,[1,-138.77093505859375,-138.77093505859375,-138.77093505859375],"maxPosition",8,[1,138.77093505859375,138.77093505859375,138.77093505859375]]],-1],0,0,[],[],[]],[[[0,"skyBox",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainColor",8,[4,4294833116],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[22,0]],[[[0,"num6",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.6,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]],[[[0,"num4",[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_TEXTURE":true,"USE_ALPHA_TEST":true}],[[[{},"tilingOffset",8,[2,0.1,1,0.4,0],"mainTexture",6,0]],11]]],0,0,[0,0],[2,1],[1,0]]]]
